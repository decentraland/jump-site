/**
 * KERNEL CODE :)
 * Thanks kernel
 */

import { config } from './config'

const PLACES_URL = config.get('PLACES_URL', '')

export type Metadata = {
  description: string
  title: string
  image: string
  owner: string
}
export interface AboutResponse {
  healthy: boolean
  acceptingUsers: boolean
}

/**
 * Checks if a string is an ENS name (ends with .eth)
 * @param str String to check
 * @returns True if the string is an ENS name
 */
export function isEns(str: string | undefined): str is `${string}.eth` {
  return !!str?.match(/^[a-zA-Z0-9.]+\.eth$/)?.length
}

/**
 * Validates a peer domain by calling its /about endpoint and checking health
 * Returns true when both healthy and acceptingUsers are true
 */

export async function isPeerHealthy(baseUrl: string): Promise<boolean> {
  try {
    const trimmed = baseUrl.replace(/\/$/, '')
    const endsWithAbout = /\/about$/i.test(trimmed)
    const urlToFetch = endsWithAbout ? trimmed : `${trimmed}/about`
    const res = await fetch(urlToFetch)
    if (!res.ok) return false
    const data: AboutResponse = await res.json()
    return data.healthy && data.acceptingUsers
  } catch {
    return false
  }
}

export async function queryData(realm: string, position: string): Promise<Metadata | undefined> {
  const url = isEns(realm) ? `${PLACES_URL}/api/worlds?names=${realm.toLowerCase()}` : `${PLACES_URL}/api/places?positions=${position}`
  const resp = await fetch(url)
  const data: { data: Metadata[] } = await resp.json()
  return data.data[0]
}

/**
 * Try to launch the desktop version using the custom protocol `decentraland://position=x,y&realm=zzz`
 * and return a boolean that represents if a loss of focus was detected on the current window
 * (assuming it was due to the interaction generated by the desktop version)
 */
export const launchDesktopApp = async (buttonTarget: EventTarget, url: string) => {
  // assume that the desktop version is installed only if
  // we detect a loss of focus on window
  let installed = false
  let isButtonReleased = false

  const isInstalled = () => {
    installed = true
  }

  const handleMouseUp = () => {
    isButtonReleased = true
  }

  window.addEventListener('blur', isInstalled)
  buttonTarget.addEventListener('mouseup', handleMouseUp)

  // inject an iframe that open the desktop version
  // NOTE: this can be also achieved with
  // ```js
  //   window.location.href = customProtocolTarget
  // ```
  // but in safari redirects into an invalid url if the desktop
  // client is not installed
  const iframe = document.createElement('iframe')
  iframe.setAttribute('style', 'display: none')
  iframe.src = url
  document.body.appendChild(iframe)

  // wait half of a second to detect the loss of focus because
  // the time it takes for the `blur` event to be fired varies
  // depending on the browser
  return new Promise<boolean>(resolve => {
    setTimeout(() => {
      window.removeEventListener('blur', isInstalled)
      buttonTarget.removeEventListener('mouseup', handleMouseUp)
      document.body.removeChild(iframe)

      // in modern browsers, the `blur` event is not fired when a custom protocol url is opened
      // so we need to check if the button was clicked and released
      if (!isButtonReleased && (buttonTarget as Element).matches(':hover')) {
        isInstalled()
      }
      resolve(installed)
    }, 500)
  })
}
